{
  "quizTitle": "Module 6: Optimize - Keep Improving Quiz",
  "quizSynopsis": "Evaluate your understanding of Agile retrospectives, performance optimization, supply chain security, multi-environment architecture, Kubernetes operators, end-to-end release automation, continuous deployment, GitOps, and Argo CD.",
  "progressBarColor": "#64a725",
  "nrOfQuestions": "20",
  "questions": [
    {
      "question": "What is the purpose of conducting an Agile retrospective?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To reflect on past work, identify improvements, and enhance future iterations",
        "To assign blame for mistakes",
        "To avoid discussing past outcomes",
        "To finalize the project without changes"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Retrospectives focus on continuous improvement by learning from past work.",
      "messageForIncorrectAnswer": "Incorrect. Retrospectives help identify what went well and what can be improved.",
      "point": "10"
    },
    {
      "question": "Why should Agile retrospectives be blameless?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To find a single person responsible for all failures",
        "To foster a safe environment focusing on systems and processes rather than individuals",
        "To discourage honest feedback",
        "To prevent acknowledging successes"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! A blameless environment encourages honesty and constructive improvement.",
      "messageForIncorrectAnswer": "Incorrect. Retros should focus on improving systems, not blaming people.",
      "point": "10"
    },
    {
      "question": "What should a retrospective produce at its conclusion?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "No changes or actions",
        "Only a list of complaints",
        "Concrete, actionable improvements",
        "A final report with no next steps"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Effective retrospectives end with specific actions to enhance future work.",
      "messageForIncorrectAnswer": "Incorrect. Without action items, retrospectives lose their purpose.",
      "point": "10"
    },
    {
      "question": "Why use data and metrics in retrospectives?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To guess which improvements to make",
        "To ignore measurable outcomes",
        "To prioritize improvements based on impact and evidence",
        "To prevent making decisions"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Data-driven insights help focus on improvements with the greatest benefit.",
      "messageForIncorrectAnswer": "Incorrect. Metrics guide more informed, priority-based decisions.",
      "point": "10"
    },
    {
      "question": "Why is it advised to avoid premature code optimization?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because initial focus should be on correctness and simplicity before micro-optimizing",
        "Because optimizing early always saves time",
        "Because performance never matters",
        "Because debugging optimized code is easier"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Optimize only when necessary to prevent complexity and wasted effort.",
      "messageForIncorrectAnswer": "Incorrect. Early optimization can create unnecessary complexity.",
      "point": "10"
    },
    {
      "question": "Which is a simple method to improve code performance?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Ignoring caching",
        "Using caching layers to reduce repeated expensive operations",
        "Running more loops",
        "Relying on frequent external API calls"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Caching reduces redundant work and speeds up application responses.",
      "messageForIncorrectAnswer": "Incorrect. Caching is a key strategy for improving performance.",
      "point": "10"
    },
    {
      "question": "When should you choose a high-performance programming language or framework?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Never consider performance requirements",
        "If you know from the start that high performance is critical",
        "After building the entire solution in a slow language",
        "Only after deployment to production"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Selecting a performance-oriented language upfront saves later optimization effort.",
      "messageForIncorrectAnswer": "Incorrect. Choosing suitable tools early can prevent later rewrites.",
      "point": "10"
    },
    {
      "question": "What role do profiling tools play in performance optimization?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They make code slower",
        "They guess where issues are randomly",
        "They provide insights into where code spends time, guiding targeted optimizations",
        "They replace developers"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Profilers reveal hotspots to focus optimization efforts effectively.",
      "messageForIncorrectAnswer": "Incorrect. Profilers help identify the most impactful optimization targets.",
      "point": "10"
    },
    {
      "question": "What is software supply chain security focused on?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Only local code written by the team",
        "Ignoring dependencies and tools",
        "Securing third-party components, dependencies, and processes in software development",
        "Preventing any security checks"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Supply chain security addresses vulnerabilities in external software and dependencies.",
      "messageForIncorrectAnswer": "Incorrect. It covers the entire chain of tools and libraries.",
      "point": "10"
    },
    {
      "question": "Why sign Git commits?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To slow down development",
        "To ensure that changes come from trusted contributors",
        "To hide the identity of the author",
        "To prevent code integration"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Signed commits verify authorship and prevent malicious changes.",
      "messageForIncorrectAnswer": "Incorrect. Signed commits boost trust in the code source.",
      "point": "10"
    },
    {
      "question": "What does SBOM (Software Bill of Materials) provide?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A list of irrelevant data",
        "An encrypted version of the code",
        "A comprehensive list of all components and dependencies in your software",
        "A marketing brochure"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! SBOMs enumerate components, enabling better vulnerability tracking.",
      "messageForIncorrectAnswer": "Incorrect. SBOMs detail all software components for security audits.",
      "point": "10"
    },
    {
      "question": "How do tools like Dependabot help secure software supply chains?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By never updating dependencies",
        "By introducing vulnerabilities",
        "By automatically detecting and updating out-of-date dependencies",
        "By removing all libraries"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Dependabot automates dependency updates, reducing exposure to known vulnerabilities.",
      "messageForIncorrectAnswer": "Incorrect. Automated updates keep dependencies patched and secure.",
      "point": "10"
    },
    {
      "question": "Why scan container images for vulnerabilities?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To ignore known security issues",
        "To ensure images are unsafe",
        "To identify and mitigate vulnerabilities before deployment",
        "To slow the CI pipeline"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Image scans detect vulnerabilities early, improving security.",
      "messageForIncorrectAnswer": "Incorrect. Early scanning prevents shipping insecure images.",
      "point": "10"
    },
    {
      "question": "What does shifting security checks left mean?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Running security checks only at the end",
        "Performing security tests as early as possible in development",
        "Avoiding security testing entirely",
        "Testing after production deployment only"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Shift-left catches issues early, reducing remediation cost and risk.",
      "messageForIncorrectAnswer": "Incorrect. Early checks detect and fix vulnerabilities sooner.",
      "point": "10"
    },
    {
      "question": "What is a common multi-environment setup?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Just production",
        "Dozens of identical production environments",
        "A few environments like dev, test, staging, and production",
        "No segregation between any environments"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Typically, several environments exist to safely test and refine changes before production.",
      "messageForIncorrectAnswer": "Incorrect. Multiple environments support safer, stepwise delivery.",
      "point": "10"
    },
    {
      "question": "Why is infrastructure as code critical in a multi-environment setup?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "It makes environments inconsistent",
        "It increases manual setup time",
        "It ensures consistent, repeatable infrastructure across all environments",
        "It prevents automation"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! IaC ensures consistency and helps manage multiple environments efficiently.",
      "messageForIncorrectAnswer": "Incorrect. IaC standardizes and automates infrastructure provisioning.",
      "point": "10"
    },
    {
      "question": "How should you represent environments in IaC?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Use branches for each environment",
        "Use directories for each environment in a single codebase",
        "Hard-code all environments in a single file",
        "Rely on manual scripts"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! A directory-based approach keeps environment definitions organized and clear.",
      "messageForIncorrectAnswer": "Incorrect. Directories help maintain clarity and avoid branching complexity.",
      "point": "10"
    },
    {
      "question": "What is environment drift?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "All environments remaining identical",
        "Environments growing more different over time",
        "Strictly syncing all environments",
        "Enforcing no differences at all"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Drift occurs when environments diverge, making testing less reliable.",
      "messageForIncorrectAnswer": "Incorrect. Drift complicates detecting issues before production.",
      "point": "10"
    },
    {
      "question": "Why have a staging environment mirror production closely?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To save costs by being completely different",
        "To ensure tests in staging closely predict real production behavior",
        "To hide real issues",
        "To avoid catching bugs"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! A similar staging environment helps uncover issues before impacting users.",
      "messageForIncorrectAnswer": "Incorrect. Staging should closely resemble production for realistic testing.",
      "point": "10"
    },
    {
      "question": "What are Kubernetes operators?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Built-in Kubernetes resources only",
        "Scripts that run outside of Kubernetes",
        "Custom extensions to Kubernetes that manage complex applications with CRDs",
        "A replacement for all Kubernetes tools"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Operators extend Kubernetes with custom logic to handle complex stateful apps.",
      "messageForIncorrectAnswer": "Incorrect. Operators use CRDs to manage domain-specific tasks.",
      "point": "10"
    },
    {
      "question": "Why are operators beneficial?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They limit Kubernetes functionality",
        "They remove automation capabilities",
        "They encode domain knowledge to automate complex tasks like upgrades and backups",
        "They make stateful apps harder to manage"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Operators bring application-specific automation and reduce manual intervention.",
      "messageForIncorrectAnswer": "Incorrect. Operators simplify managing complex workloads.",
      "point": "10"
    },
    {
      "question": "What are Custom Resource Definitions (CRDs)?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Standard Kubernetes resources",
        "Extensions that let you define new resource types for Kubernetes",
        "A way to remove Kubernetes APIs",
        "Configuration files for only storage"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! CRDs extend Kubernetes with new resource types managed by operators.",
      "messageForIncorrectAnswer": "Incorrect. CRDs add custom objects to the Kubernetes API.",
      "point": "10"
    },
    {
      "question": "What's the highest Operator maturity level?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Basic Install",
        "Full Lifecycle",
        "Auto-Pilot",
        "Seamless Upgrades"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! The Auto-Pilot level indicates fully automated management and deep insights.",
      "messageForIncorrectAnswer": "Incorrect. Auto-Pilot is the top maturity level.",
      "point": "10"
    },
    {
      "question": "What is the difference between versioned and rolling releases?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "No difference at all",
        "Versioned releases have a specific version, while rolling releases continuously update with no fixed version",
        "Rolling releases require manual updates",
        "Versioned releases never change"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Versioned releases use explicit versioning, rolling releases provide continuous updates.",
      "messageForIncorrectAnswer": "Incorrect. Versioned = set version numbers; rolling = always latest.",
      "point": "10"
    },
    {
      "question": "What ensures release quality in end-to-end release automation?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Skipping CI pipelines",
        "Ignoring quality gates",
        "Strong CI pipelines with tests, linting, and security checks",
        "Manual untracked work"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! High-quality CI pipelines enforce quality gates before release.",
      "messageForIncorrectAnswer": "Incorrect. CI best practices ensure release reliability.",
      "point": "10"
    },
    {
      "question": "Why keep all changes under version control?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To allow hidden manual tweaks",
        "To ensure no traceability",
        "To track all modifications and maintain transparency",
        "To prevent rollbacks"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Version control ensures transparency, auditability, and easy rollbacks.",
      "messageForIncorrectAnswer": "Incorrect. Everything should be tracked in Git.",
      "point": "10"
    },
    {
      "question": "How do changelogs or release notes help?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By hiding recent changes",
        "By confusing users",
        "By clearly communicating new features, bug fixes, and improvements",
        "By always being empty"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Changelogs inform stakeholders about what’s new or improved in a release.",
      "messageForIncorrectAnswer": "Incorrect. Good release notes provide transparency.",
      "point": "10"
    },
    {
      "question": "Why sign artifacts using Sigstore/Cosign?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To complicate verification",
        "To ensure integrity and authenticity of the released artifacts",
        "To hide artifacts from users",
        "To prevent distribution"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Signing verifies that artifacts haven’t been tampered with.",
      "messageForIncorrectAnswer": "Incorrect. Signatures ensure trust in your artifacts.",
      "point": "10"
    },
    {
      "question": "What is Continuous Deployment (CD) in the CI/CD pipeline?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Manual deployment after CI",
        "Occasional random deployments",
        "Regularly deploying code changes automatically to environments",
        "Skipping testing entirely"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Continuous Deployment automates and frequently moves changes into production.",
      "messageForIncorrectAnswer": "Incorrect. CD automates pushing changes to environments.",
      "point": "10"
    },
    {
      "question": "Why do some companies keep a manual approval step before production deployment?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To reduce confidence in releases",
        "To slow down delivery intentionally",
        "To maintain a final human check for critical systems",
        "To avoid any oversight"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! A manual step ensures extra caution before impacting end-users.",
      "messageForIncorrectAnswer": "Incorrect. Human approval adds a safety check.",
      "point": "10"
    },
    {
      "question": "What is the pull model in Continuous Deployment?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A system that forces updates outward",
        "A mode where the environment actively pulls new changes from a source (like Git) and updates itself",
        "A manual trigger for each deployment",
        "A push notification system"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! In the pull model, the target environment fetches changes and applies them.",
      "messageForIncorrectAnswer": "Incorrect. The environment pulls updates from a repository under the pull model.",
      "point": "10"
    },
    {
      "question": "What is GitOps?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A manual workflow",
        "A proprietary approach requiring no Git",
        "A declarative approach using Git as the source of truth for infrastructure and apps",
        "A way to replace all CI/CD tools"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! GitOps leverages Git as the single source of truth, applying declarative configurations.",
      "messageForIncorrectAnswer": "Incorrect. GitOps uses Git-based workflows for declarative deployments.",
      "point": "10"
    },
    {
      "question": "How does Argo CD fit into GitOps?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By ignoring Git repos",
        "By pushing updates without version control",
        "By continuously monitoring Git repos and reconciling Kubernetes state to match them",
        "By removing Kubernetes native integration"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Argo CD pulls desired states from Git and ensures the cluster matches that state.",
      "messageForIncorrectAnswer": "Incorrect. Argo CD automates syncing cluster configuration with Git.",
      "point": "10"
    },
    {
      "question": "What deployment model does Argo CD typically use?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Push model",
        "Imperative CLI model",
        "Pull model (the cluster pulls desired state from Git)",
        "Manual FTP deployments"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Argo CD uses a pull-based approach, aligning with GitOps principles.",
      "messageForIncorrectAnswer": "Incorrect. Argo CD continuously pulls updates into the cluster.",
      "point": "10"
    },
    {
      "question": "Which formats can Argo CD deploy?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Only binary executables",
        "Only raw JSON",
        "Helm charts, Kustomize resources, or plain Kubernetes manifests",
        "No Kubernetes resources"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Argo CD supports various Kubernetes config formats like Helm and Kustomize.",
      "messageForIncorrectAnswer": "Incorrect. Argo CD works with multiple common Kubernetes configuration methods.",
      "point": "10"
    },
    {
      "question": "Why should you avoid making on-the-fly changes via Argo CD’s UI?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because it saves changes back to Git automatically",
        "Because UI edits align perfectly with GitOps principles",
        "Because manual UI changes break the GitOps model of having Git as the single source of truth",
        "Because the UI is read-only"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Altering state outside Git violates GitOps’ declarative and trackable approach.",
      "messageForIncorrectAnswer": "Incorrect. All changes should be done via Git for proper tracking.",
      "point": "10"
    },
    {
      "question": "What is the main benefit of using Git as the single source of truth in GitOps?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Increased confusion",
        "Less traceability",
        "A clear, versioned record of desired state that’s easy to audit and revert",
        "No historical context"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Git provides versioning, audibility, and easy rollbacks, centralizing changes.",
      "messageForIncorrectAnswer": "Incorrect. GitOps leverages Git’s version control for clarity and rollback.",
      "point": "10"
    },
    {
      "question": "What is one of the recommended ways to handle Argo CD customizations?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Editing Argo CD source code directly",
        "Developing your own plugins or using existing ones",
        "Hardcoding changes in production",
        "Using proprietary, closed-source extensions only"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Argo CD supports plugins, so you can extend functionality without hacking core code.",
      "messageForIncorrectAnswer": "Incorrect. Plugins or existing integrations are the best approach.",
      "point": "10"
    },
    {
      "question": "What is the difference between Argo CD and other Argo projects?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "No difference, they are identical",
        "Argo CD, Argo Workflows, Argo Rollouts, and Argo Events serve different use cases",
        "They all focus on CI",
        "They all replace Kubernetes entirely"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Each Argo project addresses a distinct problem area, so don’t confuse Argo CD with others.",
      "messageForIncorrectAnswer": "Incorrect. Argo projects have unique roles; Argo CD focuses on GitOps-based CD.",
      "point": "10"
    }
  ]
}