{
  "quizTitle": "Module 4: Expand - Constructing a Shell Quiz",
  "quizSynopsis": "Test your knowledge of reviewing goals, the Twelve-Factor App, REST API best practices, CI best practices, Kubernetes concepts, observability, continuous delivery, and cloud computing models.",
  "progressBarColor": "#64a725",
  "nrOfQuestions": "20",
  "questions": [
    {
      "question": "Why review goals and requirements at the start of this module?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To ensure you understand what's been achieved and define what's next",
        "To add more unplanned features",
        "To discard initial planning completely",
        "To prevent updating documentation"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Revisiting goals clarifies progress and sets the direction for the next phase.",
      "messageForIncorrectAnswer": "Incorrect. Reviewing goals ensures alignment and clarifies the roadmap ahead.",
      "point": "10"
    },
    {
      "question": "What is the purpose of defining the work scope and deliverables early?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To encourage unlimited scope creep",
        "To avoid scope creep and ensure timely completion",
        "To never finalize timelines",
        "To keep requirements vague"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Clear scope and deliverables help prevent uncontrolled expansion and keep the project on track.",
      "messageForIncorrectAnswer": "Incorrect. Defined scope prevents unexpected growth and keeps focus.",
      "point": "10"
    },
    {
      "question": "Why communicate the plan in a management platform like GitHub Projects?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To hide information from the team",
        "To keep plans only in your head",
        "To make it easy for newcomers to understand direction and status",
        "To ensure no one can track progress"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! A management tool provides transparency and clarity for everyone involved.",
      "messageForIncorrectAnswer": "Incorrect. Sharing the plan helps others easily understand the project's direction.",
      "point": "10"
    },
    {
      "question": "What is the next step after defining and communicating the project plan?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Abandon the project",
        "Add more unspecified features",
        "Delay implementation indefinitely",
        "Start working on the plan according to the timeline"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! After planning, begin executing tasks as scheduled.",
      "messageForIncorrectAnswer": "Incorrect. Once the plan is set, the next step is to implement it.",
      "point": "10"
    },
    {
      "question": "Why set a realistic timeline for the work?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To ensure proper time allocation and avoid unrealistic expectations",
        "To ignore deadlines entirely",
        "To prevent any flexibility",
        "To complicate task scheduling"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! A realistic timeline helps manage expectations and ensures on-time delivery.",
      "messageForIncorrectAnswer": "Incorrect. A realistic timeline aligns resources, scope, and deadlines.",
      "point": "10"
    },
    {
      "question": "What is the main idea behind the Twelve-Factor App methodology?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To discourage cloud environments",
        "To provide best practices for building scalable, maintainable apps that thrive in the cloud",
        "To eliminate code versioning",
        "To avoid declaring dependencies"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! The Twelve-Factor App provides a set of best practices for modern, cloud-friendly applications.",
      "messageForIncorrectAnswer": "Incorrect. The 12-factor methodology ensures cloud-native, robust software development.",
      "point": "10"
    },
    {
      "question": "Which of the following is one of the Twelve Factors?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Store configuration in code directly",
        "Store config in the environment",
        "Never use revision control",
        "Always bundle the database with the app code"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! The Twelve-Factor approach includes storing config in environment variables rather than code.",
      "messageForIncorrectAnswer": "Incorrect. Configuration should be managed outside the code, often in environment variables.",
      "point": "10"
    },
    {
      "question": "Why consider the Twelve-Factor App guidelines?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because they are obsolete",
        "Because they limit scalability",
        "Because they establish a proven standard for building robust, cloud-ready apps",
        "Because they discourage best practices"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! The guidelines provide a well-established baseline for building portable, reliable, and scalable software.",
      "messageForIncorrectAnswer": "Incorrect. They guide creating cloud-native, maintainable applications.",
      "point": "10"
    },
    {
      "question": "Which factor suggests treating logs as event streams?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Dependencies",
        "Logs",
        "Admin processes",
        "Port binding"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! The Logs factor encourages treating logs as continuous event streams rather than files.",
      "messageForIncorrectAnswer": "Incorrect. The logs factor emphasizes stream-based logging for better observability.",
      "point": "10"
    },
    {
      "question": "How does Twelve-Factor methodology help with cloud adoption?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By making deployments harder",
        "By ignoring cloud capabilities",
        "By aligning apps with cloud-native principles, ensuring easier scaling and deployment",
        "By preventing stateless processes"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! It aligns apps with cloud principles, making scaling, deployment, and management easier.",
      "messageForIncorrectAnswer": "Incorrect. The methodology supports cloud adoption by standardizing app design.",
      "point": "10"
    },
    {
      "question": "Why is it helpful for a DevOps engineer to understand REST APIs?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They never deal with APIs",
        "APIs are irrelevant in modern systems",
        "Because modern tooling and systems often rely on APIs, making it essential to understand their design",
        "Because APIs replace all code"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! APIs dominate modern architectures, so understanding them helps in integration and automation.",
      "messageForIncorrectAnswer": "Incorrect. Knowing APIs is crucial since so many tools and services communicate over them.",
      "point": "10"
    },
    {
      "question": "What does 'API First' thinking imply?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Defining the API interface before writing implementation",
        "Implementing first, defining the API later",
        "Ignoring documentation",
        "Forgetting about versioning"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! 'API First' means designing the APIâ€™s interface upfront, ensuring clarity and consistency.",
      "messageForIncorrectAnswer": "Incorrect. Defining the API first aligns all development around a clear contract.",
      "point": "10"
    },
    {
      "question": "Which is a REST API best practice?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Mixing multiple distinct resources into one endpoint",
        "Using descriptive, consistent resource names and proper HTTP methods",
        "Relying on arbitrary request formats",
        "Ignoring error responses"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Good REST practices include using clear resource naming and standard HTTP methods.",
      "messageForIncorrectAnswer": "Incorrect. Consistency and clarity in endpoint naming and methods are key.",
      "point": "10"
    },
    {
      "question": "Why are REST APIs so common in modern applications?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They are rarely used",
        "They are hard to consume programmatically",
        "They provide a standard, language-agnostic way to interact with services",
        "They require specialized hardware"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! REST APIs offer a universal, language-neutral interface, making integration simpler.",
      "messageForIncorrectAnswer": "Incorrect. REST APIs are widely adopted due to their simplicity and interoperability.",
      "point": "10"
    },
    {
      "question": "What is the main goal of Continuous Integration (CI) best practices?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To complicate build processes",
        "To run tests manually each time",
        "To produce high-quality software through rapid, automated integration and testing",
        "To slow down code delivery"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! CI best practices ensure high quality by integrating and testing code changes frequently and automatically.",
      "messageForIncorrectAnswer": "Incorrect. CI speeds detection of issues and improves code reliability.",
      "point": "10"
    },
    {
      "question": "How can CI pipelines be made more efficient?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By never using caching",
        "By making them run only once a month",
        "By leveraging caching, parallelism, and scoped triggers to reduce build time",
        "By running all tests twice every time"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Use caching, parallel runs, and filtered triggers to speed up CI pipelines.",
      "messageForIncorrectAnswer": "Incorrect. Optimizing performance involves caching, parallel execution, and focusing on changed areas.",
      "point": "10"
    },
    {
      "question": "Why run CI pipelines on every commit?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To avoid finding issues early",
        "To increase manual testing",
        "To detect errors as soon as they are introduced, improving feedback and quality",
        "To reduce transparency"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Frequent runs catch issues early, giving rapid feedback and ensuring code health.",
      "messageForIncorrectAnswer": "Incorrect. Running on every commit identifies problems quickly.",
      "point": "10"
    },
    {
      "question": "What is one recommended approach to controlling CI costs?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Using the most expensive resources always",
        "Not running CI at all",
        "Using spot/preemptible instances for cheaper compute",
        "Running pipelines only on local machines"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Spot/preemptible instances can significantly cut costs without sacrificing speed.",
      "messageForIncorrectAnswer": "Incorrect. Cost management techniques help run CI efficiently and affordably.",
      "point": "10"
    },
    {
      "question": "Why keep the main branch always deployable?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "To delay releases",
        "To ensure production-ready code and enable quick deployments anytime",
        "To store untested code",
        "To avoid merging bug fixes"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! A deployable main branch ensures you can release changes quickly and confidently.",
      "messageForIncorrectAnswer": "Incorrect. Having a ready-to-deploy main branch supports fast, stable releases.",
      "point": "10"
    },
    {
      "question": "What is Kubernetes?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A programming language",
        "A single-node server system",
        "A cloud-native platform for container orchestration",
        "A tool for manual deployments only"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Kubernetes is a powerful platform that manages and orchestrates containerized workloads at scale.",
      "messageForIncorrectAnswer": "Incorrect. Kubernetes automates and scales container management.",
      "point": "10"
    },
    {
      "question": "Why did the need for Kubernetes arise?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because containers never became popular",
        "Because managing many containers manually is complex",
        "Because physical servers handle containers well without orchestration",
        "Because virtual machines replaced containers"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! As containers proliferated, a tool was needed to automate and manage them at scale.",
      "messageForIncorrectAnswer": "Incorrect. Kubernetes solves the complexity of managing numerous containers.",
      "point": "10"
    },
    {
      "question": "What is a 'Node' in Kubernetes?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "A version control system",
        "A type of container",
        "A worker machine in a Kubernetes cluster",
        "A database table"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! A Node is a worker machine that runs Pods, providing the compute resources.",
      "messageForIncorrectAnswer": "Incorrect. Nodes are the machines on which Kubernetes schedules workloads.",
      "point": "10"
    },
    {
      "question": "What is the smallest deployable unit in Kubernetes?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Cluster",
        "Node",
        "Pod",
        "Virtual machine"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! A Pod (one or more containers) is the smallest deployable unit in Kubernetes.",
      "messageForIncorrectAnswer": "Incorrect. Pods represent the smallest unit of work in Kubernetes.",
      "point": "10"
    },
    {
      "question": "Why is Kubernetes considered a standard in container orchestration?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Itâ€™s rarely used",
        "It lacks community support",
        "Itâ€™s widely adopted, open-source, and has a strong ecosystem",
        "It only supports one platform"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Kubernetesâ€™ open-source nature, feature set, and ecosystem made it the de facto standard.",
      "messageForIncorrectAnswer": "Incorrect. Its widespread adoption and community support make it a standard.",
      "point": "10"
    },
    {
      "question": "What are the three pillars of observability?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Logs, metrics, and traces",
        "CPU, RAM, and storage",
        "Users, code, and tests",
        "Build, release, run"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Logs, metrics, and traces together provide deep insight into system behavior.",
      "messageForIncorrectAnswer": "Incorrect. Observability focuses on logs, metrics, and traces.",
      "point": "10"
    },
    {
      "question": "Why is observability crucial in DevOps?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Because guesswork is efficient",
        "Because itâ€™s optional to know system state",
        "Because understanding system behavior reduces downtime and improves reliability",
        "Because it hinders troubleshooting"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Observability helps identify and resolve issues quickly, ensuring stability and performance.",
      "messageForIncorrectAnswer": "Incorrect. Observability enables quick detection and resolution of problems.",
      "point": "10"
    },
    {
      "question": "Which open-source tools are well-known in observability?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Git and SVN",
        "Docker and Kubernetes",
        "Prometheus and Grafana",
        "Excel spreadsheets"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Prometheus and Grafana are popular for metrics collection and visualization.",
      "messageForIncorrectAnswer": "Incorrect. Prometheus and Grafana are common open-source observability tools.",
      "point": "10"
    },
    {
      "question": "How should you start with observability?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Implement every tool immediately",
        "Ignore metrics and logs",
        "Start small with essential metrics and basic alerts, then expand",
        "Wait until after production failures"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Begin simply, then evolve your observability stack as needs grow.",
      "messageForIncorrectAnswer": "Incorrect. Start minimal and enhance your observability over time.",
      "point": "10"
    },
    {
      "question": "What is Continuous Delivery (CD)?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Manually deploying code once a year",
        "Automating code changes so theyâ€™re always ready for release after tests",
        "Preventing code from reaching production",
        "Skipping testing before deploying"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! CD ensures code changes are continuously prepared and validated for release.",
      "messageForIncorrectAnswer": "Incorrect. CD automates preparing code for release to production-like environments.",
      "point": "10"
    },
    {
      "question": "How does Continuous Delivery reduce deployment risk?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "By never deploying",
        "By introducing untested features",
        "By deploying small, tested increments often",
        "By requiring manual review for every line of code"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Frequent, tested deployments minimize big-bang releases and reduce risk.",
      "messageForIncorrectAnswer": "Incorrect. Smaller, frequent releases catch issues earlier.",
      "point": "10"
    },
    {
      "question": "Whatâ€™s the difference between Continuous Delivery and Continuous Deployment?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "They are the same concept",
        "Continuous Deployment automatically pushes to production, while Delivery ensures it's always ready to deploy",
        "Continuous Delivery avoids tests, Continuous Deployment relies on them",
        "Continuous Deployment is never automated"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! Continuous Delivery prepares code for release, while Continuous Deployment goes a step further and releases automatically.",
      "messageForIncorrectAnswer": "Incorrect. Delivery keeps the code deployable, Deployment actually deploys automatically.",
      "point": "10"
    },
    {
      "question": "What tools are popular for continuous delivery in the Kubernetes ecosystem?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Docker Compose and Vagrant",
        "GitHub Issues and Trello",
        "Argo CD and Flux CD",
        "Notepad and manual FTP"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Argo CD and Flux CD are well-known CD tools for Kubernetes environments.",
      "messageForIncorrectAnswer": "Incorrect. Argo CD and Flux CD are popular solutions for GitOps-based CD.",
      "point": "10"
    },
    {
      "question": "What does cloud computing refer to?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Owning physical servers personally",
        "Storing code only on local machines",
        "Accessing computing resources over the internet on-demand",
        "Replacing all software with hardware solutions"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Cloud computing provides IT resources on-demand over the Internet.",
      "messageForIncorrectAnswer": "Incorrect. Cloud computing is about remotely accessed, scalable resources.",
      "point": "10"
    },
    {
      "question": "Which is an example of a Public Cloud provider?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Your personal home server",
        "Amazon Web Services (AWS)",
        "A private on-prem data center",
        "A local machine running VMs"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! AWS, Azure, and GCP are public cloud providers accessible to anyone.",
      "messageForIncorrectAnswer": "Incorrect. AWS is a well-known public cloud service provider.",
      "point": "10"
    },
    {
      "question": "What does IaaS stand for?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Integration as a Service",
        "Infrastructure as a Service",
        "Information as a Service",
        "Indexing as a Service"
      ],
      "correctAnswer": "3",
      "messageForCorrectAnswer": "Correct! IaaS provides virtualized computing resources over the internet.",
      "messageForIncorrectAnswer": "Incorrect. IaaS refers to Infrastructure as a Service.",
      "point": "10"
    },
    {
      "question": "What distinguishes a cloud-native application?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Itâ€™s designed for on-prem environments only",
        "It cannot scale easily",
        "Itâ€™s architected to leverage cloud capabilities, scaling and self-healing dynamically",
        "It must run on physical hardware"
      ],
      "correctAnswer": "4",
      "messageForCorrectAnswer": "Correct! Cloud-native apps are built to fully exploit cloud features like scalability and resilience.",
      "messageForIncorrectAnswer": "Incorrect. Cloud-native designs embrace dynamic scaling and resilience.",
      "point": "10"
    },
    {
      "question": "Which cloud model allows a mix of public and private resources?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Public Cloud",
        "Private Cloud",
        "Hybrid Cloud",
        "Local virtualization"
      ],
      "correctAnswer": "1",
      "messageForCorrectAnswer": "Correct! Hybrid Cloud combines public and private clouds for flexible resource usage.",
      "messageForIncorrectAnswer": "Incorrect. Hybrid Cloud integrates both public and private environments.",
      "point": "10"
    },
    {
      "question": "What benefit does Cloud-Native architecture provide?",
      "questionType": "text",
      "answerSelectionType": "single",
      "answers": [
        "Less resilience and scalability",
        "Manual resource provisioning",
        "Automatic scaling, resilience, and easier maintenance",
        "Strict reliance on physical servers"
      ],
      "correctAnswer": "2",
      "messageForCorrectAnswer": "Correct! Cloud-native architecture supports auto-scaling, resilience, and efficient resource usage.",
      "messageForIncorrectAnswer": "Incorrect. Cloud-native approaches enable automated scaling and maintenance.",
      "point": "10"
    }
  ]
}